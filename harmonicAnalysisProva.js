/** DEFINITIONS: type of chords accepted
 * '' = major triad
 * min = minor triad
 * dim = diminished triad
 * aug = augmented triad
 * maj7 = major seventh
 * min7 = minor seventh
 * 7 = dominant
 * halfdim = half diminished
 * dim7 = diminished quadriad
 */

/** ASSUMPTIONS (may be modified in future updates)
 * 1) just major scale progressions
 * 2) no modal progressions
 * 2) only triads and quadriads
 */
//const chord_notation = /^[A-G][#b]?(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;
//class Chord {
//	constructor(chord){
//		if (chord_notation.test(chord)) {
//			this.chord = chord;
//		}
//		else {
//			throw "chord is not valid";
//		}
//	}
//}

// patterns for accepted chords
const note_notation = /^[A-G][#b]?$/;
const type_notation = /^(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;

// object containing notes at corresponding index, used for extracting value
const allnotes = {
	norm: ["C", "", "D", "", "E", "F", "", "G", "", "A", "", "B"],
	flat: ["", "C#", "", "D#", "", "", "F#", "", "G#", "", "A#", ""],
	sharp: ["", "Db", "", "Eb", "", "", "Gb", "", "Ab", "", "Bb", ""]
};

// array of possible scales (for now, we just use major scale)

const scales = [{
	name: 'major',
	intervals: [0, 2, 4, 5, 7, 9, 11],
	triads: ["", "min", "min", "", "", "min", "dim"],
	quadriads: ["maj7", "min7", "min7", "maj7", "7", "min7", "halfdim"]
}, {
	name: 'minor',
	intervals: [0, 2, 3, 5, 7, 8, 11],
	triads: ["min", "dim", "", "min", "min", "", ""],
	quadriads: ["min7", "halfdim", "maj7", "min7", "min7", "maj7", "7"]
}];
//every mode of ionian scale could be generated by a function 
//instead of writing it down, but for now we are just using one scale, 
//so there is no problem



//approfondisci bene che cavolo sono sti prototype e cosa cambia con le classi
function Chord(note, type) {
	this.note = note;
	this.type = type || '';
	if (! note_notation.test(this.note)) {
		throw "note is not valid";
	}
	if (! type_notation.test(this.type)) {
		throw "type is not valid";
	}
}
//vedi sopra, defining getNoteValue Method of Chord
Chord.prototype.getNoteValue = function(){
	let value = allnotes.norm.indexOf(this.note);
	console.log(value);
	if (value < 0)
		value = allnotes.flat.indexOf(this.note);
	if (value < 0)
		value = allnotes.sharp.indexOf(this.note);
	return value + 1;
}


// test progression
const progression = [];
try {
	console.log('prova');
	progression.push(new Chord('F'));
	console.log('prova');
	progression.push(new Chord('F#', 'maj7'));
	progression.push(new Chord('Gb', '7'));
	progression.push(new Chord('C', 'maj7'));
} catch (e) {
	console.error(e);
}
console.log(progression[0].getNoteValue());
console.log(progression[1].getNoteValue());
console.log(progression[2].getNoteValue());
console.log(progression[3].getNoteValue());
console.log(scales[0].intervals);

//below there are some tests, later everything will be set as a function



//first attempt to find the key
//for each chord in the progression, 
//	consider it tonic and check if other chords are compatible
//	if everything is ok, I found the tonic
for (let i = 0; i < progression.length; i++) {
	console.log(progression[i]);
}




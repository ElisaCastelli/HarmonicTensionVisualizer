/** DEFINITIONS: type of chords accepted
 * '' = major triad
 * min = minor triad
 * dim = diminished triad
 * aug = augmented triad
 * maj7 = major seventh
 * min7 = minor seventh
 * 7 = dominant
 * halfdim = half diminished
 * dim7 = diminished quadriad
 */

/** ASSUMPTIONS (may be modified in future updates)
 * 1) just major scale progressions
 * 2) no modal progressions
 * 2) only triads and quadriads
 */
//const chord_notation = /^[A-G][#b]?(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;
//class Chord {
//	constructor(chord){
//		if (chord_notation.test(chord)) {
//			this.chord = chord;
//		}
//		else {
//			throw "chord is not valid";
//		}
//	}
//}

// patterns for accepted chords
const note_notation = /^[A-G][#b]?$/;
const type_notation = /^(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;

const degrees = ["I", "II", "III", "IV", "V", "VI", "VII"];

// object containing notes at corresponding index, used for extracting value
const allnotes = {
	norm: ["C", "", "D", "", "E", "F", "", "G", "", "A", "", "B"],
	sharp: ["", "C#", "", "D#", "", "", "F#", "", "G#", "", "A#", ""],
	flat: ["", "Db", "", "Eb", "", "", "Gb", "", "Ab", "", "Bb", ""],
	letters: ["C", "D", "E", "F", "G", "A", "B"]
};


// array of possible scales (for now, we just use major scale)
const scales = [{
	name: 'major',
	intervals: [0, 2, 4, 5, 7, 9, 11],
	triads: ["", "min", "min", "", "", "min", "dim"],
	quadriads: ["maj7", "min7", "min7", "maj7", "7", "min7", "halfdim"]
}, {
	name: 'minor (aeolian)',
	intervals: [0, 2, 3, 5, 7, 8, 10],
	triads: ["min", "dim", "", "min", "min", "", ""],
	quadriads: ["min7", "halfdim", "maj7", "min7", "min7", "maj7", "7"]
}];
//}, {
//	name: 'minor (dorian)',
//	intervals: [0, 2, 3, 5, 7, 9, 10],
//	triads: ["min", "min", "", "", "min", "dim", ""],
//	quadriads: ["min7", "min7", "maj7", "7", "min7", "halfdim", "maj7"]
//}];
//every mode of major scale could be generated by a function 
//instead of writing it down


//approfondisci bene che cavolo sono sti prototype e cosa cambia con le classi
function Chord(note, type) {
	this.note = note;
	this.type = type || '';
	if (! note_notation.test(this.note)) {
		throw "note is not valid";
	}
	if (! type_notation.test(this.type)) {
		throw "type is not valid";
	}
}
//vedi sopra, defining getAbsValue Method of Chord
Chord.prototype.getAbsValue = function(){
	let value = allnotes.norm.indexOf(this.note);
	if (value < 0)
		value = allnotes.flat.indexOf(this.note);
	if (value < 0)
		value = allnotes.sharp.indexOf(this.note);	
	return value;
}
// get the value of a note, relative to the tonic
Chord.prototype.getTonicInterval = function(tonic){
	let value = this.getAbsValue();
	let shift = tonic.getAbsValue();
	if (shift != 0)
		value = value - shift >= 0 ? value - shift : value - shift + 12;
	return value;
}
Chord.prototype.toString = function(){
	return this.note.concat(this.type);
}

function getScaleIndex(scale_name){
	for (var i = 0; i < scales.length; i++) {
		if (scales[i].name == scale_name) {
			return i;
		}
	}
}

function getDegree(chord, key){
	let curr_interval = chord.getTonicInterval(new Chord(key.tonic));
	//console.log(curr_interval);
	let chord_deg_index = scales[getScaleIndex(key.scale)].intervals.indexOf(curr_interval);
	if (chord_deg_index < 0){
		chord_letter = chord.note.charAt(0);
		tonic_letter = key.tonic.charAt(0);
		let temp_degree = allnotes.letters.indexOf(chord_letter) - allnotes.letters.indexOf(tonic_letter);
		let temp_interval = scales[getScaleIndex(key.scale)].intervals[temp_degree];
		if (temp_interval + 1 == curr_interval)
			return degrees[temp_degree].concat("#");
		else
			return degrees[temp_degree].concat("b");
	}
	//console.log(chord_deg_index);
	return degrees[chord_deg_index];
}



//first attempt to find the key
//for each chord in the progression, 
//	consider it tonic and check if other chords are compatible
//	if everything is ok, I found the tonic

//for every chord in the progression


function findKey(progression){
	
	// variable for saving the current tonic hypothesis
	let tonic;
	// variable for storing every interval between a chord and the current tonic
	let curr_interval;
	
	// flag that becomes false when a tested chord is not part of the current key,
	let key_accepted;
	// if it remains true for every iteration of the inner for, then the current key is a possible solution
	// and it is added to the accepted keys.
	let accepted_keys = [];
	// BONUS
	// In the future, when introducing chord substitutions, 
	// each accepted key will gain or lose points according to different parameters (number of substitutions, kind of substitutions, ...)
	let tempKey = {};
	
	// for every possible tonic in the progression
	for (let tonic_index = 0; tonic_index < progression.length; tonic_index++) {
		// saving the current tonic
		tonic = progression[tonic_index];
		
		// for every scale known by the program
		for (let scale = 0; scale < scales.length; scale++) {
			
			//console.log('\ncurrent scale: ', tonic.note, scales[scale].name);
			// reset the flag
			key_accepted = true;
			
			// check that the chord is inside the scale "tonic.note scales[scale]"
			for (let chord = 0; chord < progression.length; chord++) {
				// evaluate interval with current tonic hypothesis
				curr_interval = progression[chord].getTonicInterval(tonic);
				
				
				// check if the interval between the two chords is contained in the scale
				if (scales[scale].intervals.includes(curr_interval)){
					
					// get the chord degree (real degree = chord_deg_index + 1, 
					// because array indexing starts from 0, while chord degrees start from 1)
					chord_deg_index = scales[scale].intervals.indexOf(curr_interval);
					chord_degree = degrees[chord_deg_index];
					// check if the type of the chord is equal to the triad or quadriad of the current scale
					triad_check = scales[scale].triads[chord_deg_index] == progression[chord].type;
					quadriad_check = scales[scale].quadriads[chord_deg_index] == progression[chord].type;
					
					// if at least one condition is true, the chord is part of the scale
					if (triad_check || quadriad_check){
						//console.log(progression[chord].toString(), 'is', chord_degree, 'degree');
					}
					else {
						//console.log(progression[chord].toString(), 'is NOT part of the scale');
						key_accepted = false;
						// break // for later optimization
					}
				}
				else {
					//console.log(progression[chord].toString(), 'is NOT part of the scale');
					key_accepted = false;
					// break // for later optimization
				}
			}
			//
			if (key_accepted){
				tempKey = {
					tonic: tonic.note,
					scale: scales[scale].name
				};
				accepted_keys.push(tempKey);
			}
		}
	}
	
	return accepted_keys;
}

// needs to distinguish between triad and quadriad
// maybe quadriads add a +1 to tension?? maybe it's not that simple
const majScaleChordFunction = [{
	name: "tonic",
	degrees: ["I", "III", "VI"],
	tension: 1
}, {
	name: "subdominant",
	degrees: ["II", "IV"],
	tension: 3
}, {
	name: "dominant",
	degrees: ["V", "VII"],
	tension: 5
}];

const progPatterns = [{
	name: "dominant resolution",
	progression: ["V", "I"],
	triads: ["", ""],
	quadriads: ["7", "maj7"],
	tension: [5, 1]
}, {
	name: "II-V movement",
	progression: ["II", "V"],
	triads: ['min', ""],
	quadriads: ["min7", "7"],
	tension: [2, 5]
}, {
	name: "II-V-I resolution",
	progression: ["II", "V", "I"],
	triads: ['min', "", ""],
	quadriads: ["min7", "7", "maj7"],
	tension: [2, 5, 1]
}, {
	name: "V of V",
	progression: ["V", "I"],
	triads: [],
	quadriads: ["7", "7"],
	tension: [5, 5]
}, {
}];

function evaluateTension(progression){
	let accepted_keys = findKey(progression);
	key = accepted_keys[0];	// for now just take the first option, which usually is the correct one
	let degrees_progression = [];
	let tension_progression = [];
	
	
	for (var i = 0; i < progression.length; i++) {
		degrees_progression.push(getDegree(progression[i], key));
	}
	return degrees_progression;
}

// test progression, try the chords you like
const progression = [];
try {
	progression.push(new Chord('Bb'));
	progression.push(new Chord('F'));
	progression.push(new Chord('C'));
	progression.push(new Chord('G', 'min'));
} catch (e) {
	console.error(e);
}

console.log('\n ACCEPTED KEYS:\n', findKey(progression));

console.log("Progression degrees:\n", evaluateTension(progression));



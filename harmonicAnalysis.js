/** DEFINITIONS: type of chords accepted
 * '' = major triad
 * min = minor triad
 * dim = diminished triad
 * aug = augmented triad
 * maj7 = major seventh
 * min7 = minor seventh
 * 7 = dominant
 * halfdim = half diminished
 * dim7 = diminished quadriad
 */

/** ASSUMPTIONS (may be modified in future updates)
 * 1) just major scale progressions
 * 2) no modal progressions
 * 2) only triads and quadriads
 */
//const chord_notation = /^[A-G][#b]?(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;
//class Chord {
//	constructor(chord){
//		if (chord_notation.test(chord)) {
//			this.chord = chord;
//		}
//		else {
//			throw "chord is not valid";
//		}
//	}
//}

// patterns for accepted chords
const note_notation = /^[A-G][#b]?$/;
const type_notation = /^(min|dim|aug|maj7|min7|7|halfdim|dim7)?$/;

const degrees = ["I", "II", "III", "IV", "V", "VI", "VII"];

// object containing notes at corresponding index, used for extracting value
const allnotes = {
	norm: ["C", "", "D", "", "E", "F", "", "G", "", "A", "", "B"],
	sharp: ["", "C#", "", "D#", "", "", "F#", "", "G#", "", "A#", ""],
	flat: ["", "Db", "", "Eb", "", "", "Gb", "", "Ab", "", "Bb", ""],
	letters: ["C", "D", "E", "F", "G", "A", "B"]
};


// array of possible scales
const scales = [{
	name: 'major (Ionian)',
	intervals: [0, 2, 4, 5, 7, 9, 11],
	triads: ["", "min", "min", "", "", "min", "dim"],
	quadriads: ["maj7", "min7", "min7", "maj7", "7", "min7", "halfdim"],
}, {
	name: 'Dorian',
	intervals: [0, 2, 3, 5, 7, 9, 10],
	triads: ["min", "min", "", "", "min", "dim", ""],
	quadriads: ["min7", "min7", "maj7", "7", "min7", "halfdim", "maj7"]
}, {
	name: 'Phrygian',
	intervals: [0, 1, 3, 5, 7, 8, 10],
	triads: ["min", "", "", "min", "dim", "", "min"],
	quadriads: ["min7", "maj7", "7", "min7", "halfdim", "maj7", "min7"]
}, {
	name: 'Lydian',
	intervals: [0, 2, 4, 6, 7, 9, 11],
	triads: ["", "", "min", "dim", "", "min", "min"],
	quadriads: ["maj7", "7", "min7", "halfdim", "maj7", "min7", "min7"]
}, {
	name: 'Mixolydian',
	intervals: [0, 2, 4, 5, 7, 9, 10],
	triads: ["", "min", "dim", "", "min", "min", ""],
	quadriads: ["7", "min7", "halfdim", "maj7", "min7", "min7", "maj7"]
}, {
	name: 'Minor (aeolian)',
	intervals: [0, 2, 3, 5, 7, 8, 10],
	triads: ["min", "dim", "", "min", "min", "", ""],
	quadriads: ["min7", "halfdim", "maj7", "min7", "min7", "maj7", "7"]
}, {
	name: 'Locrian',
	intervals: [0, 1, 3, 5, 6, 8, 10],
	triads: ["dim", "", "min", "min", "", "", "min"],
	quadriads: ["halfdim", "maj7", "min7", "min7", "maj7", "7", "min7"]
}];

//array of major scale modes
/*const modes = [{
	name: 'dorian',
	intervals: [0, 2, 4, 5, 7, 9, 11],
	triads: ["", "min", "min", "", "", "min", "dim"],
	quadriads: ["maj7", "min7", "min7", "maj7", "7", "min7", "halfdim"]
}, {
	name: 'minor (aeolian)',
	intervals: [0, 2, 3, 5, 7, 8, 10],
	triads: ["min", "dim", "", "min", "min", "", ""],
	quadriads: ["min7", "halfdim", "maj7", "min7", "min7", "maj7", "7"]
}];*/

//}, {
//	name: 'minor (dorian)',
//	intervals: [0, 2, 3, 5, 7, 9, 10],
//	triads: ["min", "min", "", "", "min", "dim", ""],
//	quadriads: ["min7", "min7", "maj7", "7", "min7", "halfdim", "maj7"]
//}];
//every mode of major scale could be generated by a function 
//instead of writing it down


//approfondisci bene che cavolo sono sti prototype e cosa cambia con le classi
function Chord(note, type) {
	this.note = note;
	this.type = type || '';
	if (! note_notation.test(this.note)) {
		throw "note is not valid";
	}
	if (! type_notation.test(this.type)) {
		throw "type is not valid";
	}
}
//vedi sopra, defining getAbsValue Method of Chord
Chord.prototype.getAbsValue = function(){
	let value = allnotes.norm.indexOf(this.note);
	if (value < 0)
		value = allnotes.flat.indexOf(this.note);
	if (value < 0)
		value = allnotes.sharp.indexOf(this.note);	
	return value;
}
// get the value of a note, relative to the tonic
Chord.prototype.getTonicInterval = function(tonic){
	let value = this.getAbsValue();
	let shift = tonic.getAbsValue();
	if (shift != 0)
		value = value - shift >= 0 ? value - shift : value - shift + 12;
	return value;
}
Chord.prototype.toString = function(){
	return this.note.concat(this.type);
}

function getScaleIndex(scale_name){
	for (var i = 0; i < scales.length; i++) {
		if (scales[i].name == scale_name) {
			return i;
		}
	}
}

function getDegree(chord, key){
	if (key == null) {
		throw "no key was given";
		return 0;
	}
	let curr_interval = chord.getTonicInterval(new Chord(key.tonic));
	let chord_deg_index = scales[getScaleIndex(key.scale)].intervals.indexOf(curr_interval);
	// if note out of scale
	if (chord_deg_index < 0){
		chord_letter = chord.note.charAt(0);
		tonic_letter = key.tonic.charAt(0);
		let temp_degree = allnotes.letters.indexOf(chord_letter) - allnotes.letters.indexOf(tonic_letter);
		// if the difference returns a negative value
		if (temp_degree < 1) {
			//set the real degree value
			temp_degree = Math.abs(temp_degree) + 1;
			//get the reciprocal interval, then remove the 1 added before
			temp_degree = 9 - temp_degree - 1;
		}
		let temp_interval = scales[getScaleIndex(key.scale)].intervals[temp_degree];
		if (temp_interval + 1 == curr_interval)
			return degrees[temp_degree].concat("#");
		else
			return degrees[temp_degree].concat("b");
	}
	//console.log(chord_deg_index);
	return degrees[chord_deg_index];
}



//first attempt to find the key
//for each chord in the progression, 
//	consider it tonic and check if other chords are compatible
//	if everything is ok, I found the tonic

//for every chord in the progression


function findKey(progression){
	
	// variable for saving the current tonic hypothesis
	let tonic;
	// variable for storing every interval between a chord and the current tonic
	let curr_interval;
	
	// each accepted key will gain or lose points according to different parameters (number of substitutions, kind of substitutions, ...)
	let accepted_keys = [];
	let tempKey = {};
	
	// for every possible tonic in the progression
	for (let tonic_index = 0; tonic_index < progression.length; tonic_index++) {
		// saving the current tonic
		tonic = progression[tonic_index];
		
		// for every scale known by the program
		for (let scale = 0; scale < scales.length; scale++) {
			
			// reset the counter
			tempKey = {
				tonic: tonic.note,
				scale: scales[scale].name,
				points: 0
			};
			// check that the chord is inside the scale "tonic.note scales[scale]"
			for (let chord = 0; chord < progression.length; chord++) {
				// evaluate interval with current tonic hypothesis
				curr_interval = progression[chord].getTonicInterval(tonic);
				
				
				// check if the interval between the two chords is contained in the scale
				if (scales[scale].intervals.includes(curr_interval)){
					
					// get the chord degree (real degree = chord_deg_index + 1, 
					// because array indexing starts from 0, while chord degrees start from 1)
					chord_deg_index = scales[scale].intervals.indexOf(curr_interval);
					chord_degree = degrees[chord_deg_index];
					
					// check if the type of the chord is equal to the triad or quadriad of the current scale
					triad_check = scales[scale].triads[chord_deg_index] == progression[chord].type;
					quadriad_check = scales[scale].quadriads[chord_deg_index] == progression[chord].type;
					// point assignment
					if (chord_degree == "I" && (triad_check || quadriad_check)) {
						tempKey.points+=2;
					}
					else if (accepted_keys.length > 1 && accepted_keys[accepted_keys.length - 1].scale == scales[scale].name && (triad_check || quadriad_check)) {
						tempKey.points+=2;
					} 
					else if (triad_check || quadriad_check){
						//console.log(progression[chord].toString(), 'is', chord_degree, 'degree');
						tempKey.points++;
					}
					else {
						//console.log(progression[chord].toString(), 'is NOT part of the scale');
						tempKey.points--;
						// break // for later optimization
					}
				} else {
					//console.log(progression[chord].toString(), 'is NOT part of the scale');
					tempKey.points--;
					// break // for later optimization
				}
			}
			
			accepted_keys.push(tempKey);
			
			for (let i = 0; i < accepted_keys.length - 1; i++) {
				if (tempKey.tonic == accepted_keys[i].tonic && tempKey.scale == accepted_keys[i].scale){
					accepted_keys[i].points += tempKey.points;
					accepted_keys.pop();
					break;
				}
			}
		}
	}
	accepted_keys.sort((a, b) => (a.points > b.points) ? -1 : 1);
	return accepted_keys;
}

// needs to distinguish between triad and quadriad
// maybe quadriads add a +1 to tension?? maybe it's not that simple
const majScaleChordFunction = [{
	name: "tonic",
	degrees: ["I", "III", "VI"],
	tension: 1
}, {
	name: "subdominant",
	degrees: ["II", "IV"],
	tension: 3
}, {
	name: "dominant",
	degrees: ["V", "VII"],
	tension: 5
}];

const progPatterns = [{
	name: "dominant resolution",
	degrees: ["V", "I"],
	triads: ["", ""],
	quadriads: ["7", "maj7"],
	tension: [5, 1]
}, {
	name: "II-V-I resolution",
	degrees: ["II", "V", "I"],
	triads: ['min', "", ""],
	quadriads: ["min7", "7", "maj7"],
	tension: [3, 6, 1]	// se arrivo da un 2, il 5 è potenziato di tensione
}, {
	name: "II-V movement",
	degrees: ["II", "V"],
	triads: ['min', ""],
	quadriads: ["min7", "7"],
	tension: [3, 5]
}, {
	name: "V of V",
	degrees: ["V", "I"],
	triads: [],
	quadriads: ["7", "7"],
	tension: [5, 5]
}];

function evaluateTension(progression){
	let accepted_keys = findKey(progression);
	if (accepted_keys.length == 0) {
		throw "no key was given";
	}
	key = accepted_keys[0];	// take the first option, which should the correct one
	let degrees_progression = [];
	let tension_progression = new Array(progression.length);
	tension_progression.fill(1);
	
	let deg_chord = {};
	
	// DEGREE PROGRESSION
	for (let i = 0; i < progression.length; i++) {

		deg_chord = {
			degree: getDegree(progression[i], key),
			type: progression[i].type,
			type_coherent: true
		};
		// check if the degree type is different from its scale
		triad_check = scales[0].triads[degrees.indexOf(deg_chord.degree)] == progression[i].type;
		quadriad_check = scales[0].quadriads[degrees.indexOf(deg_chord.degree)] == progression[i].type;
		if (! (triad_check || quadriad_check)) {
			deg_chord.type_coherent = false;
		}
		degrees_progression.push(deg_chord);
	}
	// TENSION PROGRESSION
	
	// only for major scales, diatonic substitutions
	if (key.scale == "major (Ionian)"){
		for (let i = 0; i < degrees_progression.length; i++) {
			for (let j = 0; j < majScaleChordFunction.length; j++) {
				if (majScaleChordFunction[j].degrees.indexOf(degrees_progression[i].degree) >= 0 && degrees_progression[i].type_coherent) {
					tension_progression[i] = majScaleChordFunction[j].tension;
				}
			}
		}
	}
	
	progPatterns.sort((a, b) => (a.tension.length > b.tension.length) ? -1 : 1);
	for (let i = 0; i < degrees_progression.length; i++) {	
		let found_pattern;
		let pattern;
		for (let p = 0; p < progPatterns.length; p++) {
			pattern = degrees_progression.slice(i, i + progPatterns[p].degrees.length);
			found_pattern = true;
			for (let j = 0; j < pattern.length; j++) {
				if (pattern[j].degree == progPatterns[p].degrees[j] && 
						(pattern[j].type == progPatterns[p].triads[j] || 
						pattern[j].type == progPatterns[p].quadriads[j])) {
				}
				else {
					found_pattern = false;
					break;
				}
				
			}
			if (found_pattern) {
				console.log("found pattern:", progPatterns[p].name);
				Array.prototype.splice.apply(tension_progression, [i, progPatterns[p].tension.length].concat(progPatterns[p].tension));
				i += progPatterns[p].tension.length;
				break;
			}
		}
		
	}
	return [degrees_progression, tension_progression];
}

// test progression, try the chords you like
const progression = [];
try {
	progression.push(new Chord('C'));
	progression.push(new Chord('A', 'min'));
	progression.push(new Chord('F'));
	progression.push(new Chord('G', '7'));
	progression.push(new Chord('C'));
} catch (e) {
	console.error(e);
}

console.log('\n ACCEPTED KEYS:\n', findKey(progression));
try {
	console.log("Progression degrees and tension array:\n", evaluateTension(progression));
} catch (e) {
	console.error(e);
}

// Harmony analysis
// - quadriadi + tese di triadi
// - raggruppare pattern per scala?
// - majScaleChordFunction solo controllo per scala maggiore	FATTO
// - harmony analysis cambia pattern/sostituzioni considerate in base a a scala
// - pattern cambiano tensione in base a triade o quadriade (II V I triade è meno teso della corrispondente quadriade)
// - cerca sostituzioni e interscambi modali
// - se arrivo da un 2, il 5 è potenziato di tensione	FATTO, MA DA RIVEDERE


